# -*- coding: utf-8 -*-
"""Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1MSihGD62LdhoPFqrD_tiAT9dczTIuvtq
"""


# Импорт библиотек
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.preprocessing import MinMaxScaler

# Ввод данных
df = pd.read_csv('file.csv', sep = ';',encoding='utf-8')
df = df.set_index('Критерии')
df.index.name = None
dfrn = pd.read_csv('restriction num.csv', sep = ';',encoding='utf-8')
dfrn = dfrn.set_index('Критерии')
dfrn.index.name = None
dfrs = pd.read_csv('restriction str.csv', sep = ';',encoding='utf-8')
df

# Проверка файлов

for critiria in dfrn.index:
    if critiria not in df.index:
        print(f"Критерий '{critiria}', на который наложено ограничение, не найден в исходном датафрейме.")

for critiria in dfrs.columns:
    if critiria not in df.index:
        print(f"Критерий '{critiria}', на который наложено ограничение, не найден в исходном датафрейме.")

# Учет ограничений на категориальные данные

for column in dfrs.columns:
  for index in df.index:
    if column == index:
      list1 = dfrs[column].tolist()
      for i in df.columns:
        if df.loc[index, i] not in list1:
          df.drop(i, axis = 1, inplace = True)

# Задайте важность критериев по 10 балльной шкале, где 1 - неважный, 10 - очень важный.

weights = np.array([])
for criteria in df.index:
    print(criteria)
    while True:
        try:
            weight = float(input())
            if weight < 1 or weight > 10:
                print("Пожалуйста, введите число между 1 и 10!")
            else:
                break
        except ValueError:
            print("Пожалуйста, введите числовое значение!")

    weights = np.append(weights, weight)
normalized_weights = weights/sum(weights)

# Проранжируйте в таблице категориальные признаки.

df_transposed = df.T
for column in df_transposed.columns:
    mapping_dict = {}
    if any(df_transposed[column].astype(str).str.isalpha()):
        print(f'Проранжируйте следующие категориальные значения в колонке {column}: {", ".join(df_transposed[column].unique())}')
        print()
        for unique_value in df_transposed[column].unique():
            while True:
                try:
                    value = float(input(f'Введите числовое значение для {unique_value}: '))
                    break
                except ValueError:
                    print('Пожалуйста, введите числовое значение!')

            mapping_dict[unique_value] = str(value)

        df_transposed[column] = df_transposed[column].map(mapping_dict)

# Приводим все к числовому типу

df_transposed = df_transposed.apply(lambda x: x.str.replace(',', '.')).astype(float)

# Определите критерии, которые влияют прямо пропорционально и обратно пропорционально на выбор альтернативы.

how_impact = np.array([])
for criteria in df.index:
  print(criteria)
  while True:
    impact = input()
    if impact not in ['0', '1']:
      print("Пожалуйста, введите 1 и 0!")
    else:
      how_impact = np.append(how_impact, int(impact))
      break

# Учет ограничений числовых переменных

df_transposed

for index in dfrn.index:
  if dfrn.isnull().loc[index, 'Мин'] == True:
    dfrn.loc[index, 'Мин'] = min(df_transposed[index])

for index in dfrn.index:
  if dfrn.isnull().loc[index, 'Макс'] == True:
    dfrn.loc[index, 'Макс'] = max(df_transposed[index])


for column in dfrn.columns:
  dfrn[column] = dfrn[column].astype(str)

dfrn = dfrn.apply(lambda x: x.str.replace(',', '.')).astype(float)

for index in dfrn.index:
  df_transposed = df_transposed[
    (df_transposed[index] >= dfrn.loc[index, 'Мин']) & (df_transposed[index] <= dfrn.loc[index, 'Макс']) &
    (df_transposed[index] >= dfrn.loc[index, 'Мин']) & (df_transposed[index] <= dfrn.loc[index, 'Макс'])]

# Учет критериев, влияющих обратно пропорциоанально

for i in np.where (how_impact == 1):
  df_transposed.iloc[:,i] = 1/df_transposed.iloc[:,i]
df_transposed

# Нормализация

scaler = MinMaxScaler()
df_transposed.iloc[:,:] = scaler.fit_transform(df_transposed.iloc[:,:])
df_transposed

df_result = df_transposed.T
df_result

# Подсчет итоговых оценок и вывод графиков

mult = []
for column in df_result.columns:
  mult.append(np.dot(normalized_weights, df_result[column]))
df_sorted = pd.DataFrame({'Альтернативы': df_result.columns.tolist(), 'Итоговый результат': mult})
df_sorted = df_sorted.sort_values(by='Итоговый результат', ascending=False)


colors = ['green'] + ['gray'] * (len(df_sorted) - 1)
sns.barplot(x=df_sorted['Альтернативы'], y=df_sorted['Итоговый результат'], data=df_sorted, palette=colors)
plt.xticks(rotation=90)
plt.title('Отсортированные оптимальные альтернативы с учетом ограничений')
plt.show()

x = df_result.index.tolist()
plt.figure(figsize=(8, 4))
for i in df_result.columns.tolist():
  y = df_result[i]
  plt.plot(x, y, label=i)
plt.legend()
plt.grid(True)
plt.xticks(rotation=90)
plt.title('Оценки альтернатив по безразмерным критериям')
plt.show()
